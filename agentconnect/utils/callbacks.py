"""
Agent activity tracing and status update callback handler for AgentConnect.

This module provides a LangChain callback handler for tracking agent activity,
including tool usage, LLM calls, chain steps, and the LLM's generated text output
(which may contain reasoning steps), with configurable console output.
"""

import logging
import json
import re  # Add re import at the top
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from colorama import Fore, Style
from langchain_core.agents import AgentAction
from langchain_core.callbacks import BaseCallbackHandler
from langchain_core.messages import ToolMessage, AIMessage

# from langchain_core.outputs import LLMResult, ChatGeneration

# Configure logger
logger = logging.getLogger(__name__)

# Define max lengths for logging to prevent clutter
MAX_INPUT_DETAIL_LENGTH = 150
MAX_OUTPUT_PREVIEW_LENGTH = 100
MAX_ERROR_MESSAGE_LENGTH = 200

# Define colors for logging
TOOL_COLOR = Fore.MAGENTA
TOOL_SUCCESS_COLOR = Fore.GREEN
TOOL_ERROR_COLOR = Fore.RED
LLM_COLOR = Fore.BLUE  # Color for LLM activity
CHAIN_COLOR = Fore.CYAN  # Color for chain/step activity
REASONING_COLOR = Fore.LIGHTBLUE_EX


class ToolTracerCallbackHandler(BaseCallbackHandler):
    """
    Callback handler for tracing agent activity. Logs detailed activity and
    optionally prints concise updates (like LLM generation text, tool usage, etc.)
    to the console based on configuration.
    """

    def __init__(
        self,
        agent_id: str,
        print_tool_activity: bool = True,  # Default ON
        print_reasoning_steps: bool = True,  # Default ON - Print LLM generation text
    ):
        """
        Initialize the callback handler.

        Args:

            agent_id: The ID of the agent this handler is tracking.
            print_tool_activity: If True, print tool start/end/error to console.
            print_reasoning_steps: If True, print the reasoning steps generated by the LLM. (If any)
        """
        super().__init__()
        self.agent_id = agent_id
        self.print_tool_activity = print_tool_activity
        self.print_reasoning_steps = print_reasoning_steps

        # Initial message is logged only once
        init_msg = (
            f"AgentActivityMonitor initialized for Agent ID: {self.agent_id} "
            f"(Tools: {print_tool_activity}, Reasoning Text: {print_reasoning_steps}, "
        )
        logger.info(init_msg)

    def _format_details(self, details: Any, max_length: int) -> str:
        """Formats details for logging, handling different types and truncating."""
        if isinstance(details, dict):
            try:
                detail_str = json.dumps(details)
            except TypeError:
                detail_str = str(details)
        else:
            detail_str = str(details)
        if len(detail_str) > max_length:
            return f"{detail_str[:max_length - 3]}..."
        return detail_str

    def _get_short_snippet(self, text: str, max_length: int = 50) -> str:
        """Create a short snippet from the text."""
        if not text:
            return "..."
        text_str = str(text)
        if len(text_str) > max_length:
            return f"{text_str[:max_length]}..."
        return text_str

    def on_tool_start(
        self,
        serialized: Dict[str, Any],
        input_str: str,
        *,
        run_id: UUID,
        parent_run_id: Optional[UUID] = None,
        tags: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        inputs: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -> Any:
        """
        Run when the tool starts running.

        Args:
            serialized (Dict[str, Any]): The serialized tool.
            input_str (str): The input string.
            run_id (UUID): The run ID. This is the ID of the current run.
            parent_run_id (UUID): The parent run ID. This is the ID of the parent run.
            tags (Optional[List[str]]): The tags.
            metadata (Optional[Dict[str, Any]]): The metadata.
            inputs (Optional[Dict[str, Any]]): The inputs.
            kwargs (Any): Additional keyword arguments.
        """

        tool_name = serialized.get("name", "UnknownTool")
        input_details_raw = inputs if inputs is not None else input_str
        input_details_formatted = self._format_details(
            input_details_raw, MAX_INPUT_DETAIL_LENGTH
        )
        log_message = f"[TOOL START] Agent: {self.agent_id} | Tool: {tool_name} | Input: {input_details_formatted}"
        logger.info(log_message)

        if self.print_tool_activity:
            print_msg = ""
            # Safely get inputs, providing defaults if they don't exist
            safe_inputs = inputs if isinstance(inputs, dict) else {}

            if tool_name == "search_for_agents":
                capability = safe_inputs.get("capability_name", "unknown capability")
                print_msg = f"{TOOL_COLOR}ðŸ”Ž Searching for agents with capability: {capability}...{Style.RESET_ALL}"
            elif tool_name == "send_collaboration_request":
                target_agent = safe_inputs.get("target_agent_id", "unknown agent")
                task_snippet = self._get_short_snippet(
                    safe_inputs.get("task", "unknown task"), 50
                )
                print_msg = f"{TOOL_COLOR}ðŸ¤ Interacting with {target_agent}: {task_snippet}...{Style.RESET_ALL}"
            elif tool_name == "WalletActionProvider_native_transfer":
                amount = safe_inputs.get("amount", "unknown amount")
                amount = int(amount) / 10**18
                asset = safe_inputs.get("asset_id", "ETH")
                dest = self._get_short_snippet(
                    safe_inputs.get("destination", "unknown destination"), 20
                )
                print_msg = f"{TOOL_COLOR}ðŸ’¸ Initiating transfer of {amount} {asset} to {dest}...{Style.RESET_ALL}"
            elif (
                tool_name == "ERC20ActionProvider_transfer"
            ):  # Assuming this is for ERC20 transfer
                amount = safe_inputs.get("amount", "unknown amount")
                amount = int(amount) / 10**6
                asset = safe_inputs.get(
                    "asset_id", "USDC"
                )  # Asset ID usually IS the token address/symbol here
                dest = self._get_short_snippet(
                    safe_inputs.get("destination", "unknown destination"), 20
                )
                print_msg = f"{TOOL_COLOR}ðŸ’¸ Initiating transfer of {amount} {asset} to {dest}...{Style.RESET_ALL}"
            elif tool_name == "WalletActionProvider_get_balance":
                print_msg = (
                    f"{TOOL_COLOR}ðŸ’° Checking native token balance...{Style.RESET_ALL}"
                )
            elif tool_name == "WalletActionProvider_get_wallet_details":
                print_msg = f"{TOOL_COLOR}â„¹ï¸ Fetching wallet details (address, network, balances)...{Style.RESET_ALL}"
            elif tool_name == "CdpApiActionProvider_address_reputation":
                address = self._get_short_snippet(
                    safe_inputs.get("address", "unknown address"), 20
                )
                print_msg = f"{TOOL_COLOR}ðŸ›¡ï¸ Checking reputation for address: {address}...{Style.RESET_ALL}"
            elif tool_name == "CdpApiActionProvider_request_faucet_funds":
                asset = safe_inputs.get("asset_id", "ETH")
                print_msg = f"{TOOL_COLOR}ðŸš° Requesting faucet funds ({asset})...{Style.RESET_ALL}"
            elif tool_name == "ERC20ActionProvider_get_balance":
                token = self._get_short_snippet(
                    safe_inputs.get("contract_address", "unknown token"), 15
                )
                owner = self._get_short_snippet(
                    safe_inputs.get("address", "wallet"), 15
                )
                print_msg = f"{TOOL_COLOR}ðŸ’° Checking balance of token {token} for {owner}...{Style.RESET_ALL}"
            else:
                # Fallback to generic message for other tools
                input_snippet = self._get_short_snippet(
                    (
                        json.dumps(input_details_raw)
                        if isinstance(input_details_raw, dict)
                        else input_details_raw
                    ),
                    80,
                )
                print_msg = f"{TOOL_COLOR}ðŸ› ï¸ [Tool Start] {tool_name}({input_snippet}...){Style.RESET_ALL}"

            if print_msg:
                print(print_msg)

    def on_tool_end(
        self,
        output: Any,
        *,
        run_id: UUID,
        parent_run_id: Optional[UUID] = None,
        tags: Optional[List[str]] = None,
        name: str = "UnknownTool",
        **kwargs: Any,
    ) -> Any:
        """
        Run when the tool ends running.

        Args:
            output (Any): The output of the tool.
            run_id (UUID): The run ID. This is the ID of the current run.
            parent_run_id (UUID): The parent run ID. This is the ID of the parent run.
            kwargs (Any): Additional keyword arguments.
        """

        tool_name = kwargs.get("name", name)
        output_type = type(output).__name__
        output_preview = self._format_details(output, MAX_OUTPUT_PREVIEW_LENGTH)
        log_message = f"[TOOL END] Agent: {self.agent_id} | Tool: {tool_name} | Status: Success | Output Type: {output_type} | Preview: {output_preview}"
        logger.debug(log_message)

        if self.print_tool_activity:
            print_msg = ""
            output_str = str(output)  # Keep for general logging if needed

            if tool_name == "send_collaboration_request":
                status = "processed."
                response_snippet = ""
                success = None  # Track success status explicitly
                json_data = None

                # Primary Case: Handle ToolMessage output
                if isinstance(output, ToolMessage):
                    content_str = output.content
                    if isinstance(content_str, str):
                        try:
                            json_data = json.loads(content_str)
                        except json.JSONDecodeError as e:
                            logger.warning(
                                f"ToolMessage content is not valid JSON for {tool_name}: {content_str[:100]}... Error: {e}"
                            )
                            status = "returned unparsable content."
                            response_snippet = f" Raw content: {self._get_short_snippet(content_str, 60)}..."
                    else:
                        logger.warning(
                            f"ToolMessage content is not a string for {tool_name}: {type(content_str)}"
                        )
                        status = "returned non-string content."
                        response_snippet = f" Content: {self._get_short_snippet(str(content_str), 60)}..."

                # Fallback 1: Attempt to parse JSON from string representation
                elif isinstance(output, str):
                    logger.debug(
                        f"Fallback: {tool_name} output is a string, attempting parse."
                    )
                    # Try to find JSON within content='...' or content="..."
                    match = re.search(r'content=(["\'])(.*?)\1', output, re.DOTALL)
                    if match:
                        json_str = match.group(2)
                        try:
                            json_data = json.loads(json_str)
                        except json.JSONDecodeError as e:
                            logger.debug(
                                f"Failed to parse JSON from content in string: {e}"
                            )
                            status = "returned unparsable content string."
                            response_snippet = (
                                f" Raw output: {self._get_short_snippet(output, 60)}..."
                            )
                    else:
                        # If no content= pattern, try parsing the whole string as JSON
                        try:
                            json_data = json.loads(output)
                        except json.JSONDecodeError:
                            logger.debug(
                                f"Output string is not valid JSON: {output_str[:100]}..."
                            )
                            status = "completed with non-JSON string output."
                            response_snippet = (
                                f" Output: {self._get_short_snippet(output, 60)}..."
                            )

                # Fallback 2: Handle dictionary output directly
                elif isinstance(output, dict):
                    logger.debug(f"Fallback: {tool_name} output is a dict.")
                    json_data = output

                # Process extracted/provided JSON data (if successfully parsed)
                if json_data and isinstance(json_data, dict):
                    success = json_data.get("success")
                    if success is True:
                        status = "completed successfully."
                        response_snippet = f" Response: {self._get_short_snippet(json_data.get('response'), 60)}..."
                    elif success is False:
                        status = "failed."
                        error_reason = json_data.get("response", "Unknown reason")
                        response_snippet = f" Reason: {self._get_short_snippet(str(error_reason), 60)}..."
                    else:  # Success field missing or not boolean
                        status = "completed with unexpected JSON structure."
                        response_snippet = f" Data: {self._get_short_snippet(json.dumps(json_data), 60)}..."
                # Final Fallback: If output wasn't ToolMessage, str, or dict, or if JSON parsing failed earlier
                elif status == "processed.":  # Only trigger if no other status was set
                    status = "completed with unexpected output type."
                    response_snippet = f" Type: {output_type}, Output: {self._get_short_snippet(output_str, 60)}..."
                    logger.warning(
                        f"Unexpected output type {output_type} for {tool_name}. Output: {output_str[:100]}..."
                    )

                # Determine color based on final success status
                color = (
                    TOOL_SUCCESS_COLOR
                    if success is True
                    else TOOL_ERROR_COLOR if success is False else Fore.YELLOW
                )  # Yellow for unknown/unexpected

                print_msg = f"{color}âž¡ï¸ Collaboration request {status}{response_snippet}{Style.RESET_ALL}"

            if print_msg:
                print(print_msg)

    def on_tool_error(
        self,
        error: Union[Exception, KeyboardInterrupt],
        *,
        run_id: UUID,
        parent_run_id: Optional[UUID] = None,
        tags: Optional[List[str]] = None,
        name: str = "UnknownTool",
        **kwargs: Any,
    ) -> Any:
        """
        Run when tool errors.

        Args:
            error (BaseException): The error that occurred.
            run_id (UUID): The run ID. This is the ID of the current run.
            parent_run_id (UUID): The parent run ID. This is the ID of the parent run.
            kwargs (Any): Additional keyword arguments.
        """

        tool_name = kwargs.get("name", name)
        error_type = type(error).__name__
        error_message_raw = str(error)
        error_message_formatted_log = self._format_details(
            error_message_raw, MAX_ERROR_MESSAGE_LENGTH
        )
        log_message = f"[TOOL ERROR] Agent: {self.agent_id} | Tool: {tool_name} | Status: Failed | Error: {error_type} - {error_message_formatted_log}"
        logger.error(log_message)

        # --- Commented out console printing for tool error ---
        # if self.print_tool_activity:
        #     print_msg = ""
        #     error_message_snippet = self._get_short_snippet(error_message_raw, 100)
        #
        #     if tool_name == "search_for_agents":
        #         print_msg = f"{TOOL_ERROR_COLOR}âŒ Agent search failed unexpectedly: {error_message_snippet}...{Style.RESET_ALL}"
        #     elif tool_name == "send_collaboration_request":
        #         print_msg = f"{TOOL_ERROR_COLOR}âŒ Collaboration request failed unexpectedly during execution: {error_message_snippet}...{Style.RESET_ALL}"
        #     elif tool_name == "WalletActionProvider_native_transfer" or tool_name == "ERC20ActionProvider_transfer":
        #          payment_type = "Payment" if tool_name == "WalletActionProvider_native_transfer" else "Token Transfer"
        #          print_msg = f"{TOOL_ERROR_COLOR}âŒ {payment_type} failed during execution: {error_message_snippet}...{Style.RESET_ALL}"
        #     else:
        #         # Fallback for generic errors
        #         print_msg = f"{TOOL_ERROR_COLOR}âŒ [Tool Error] {tool_name} failed: {error_type} - {error_message_snippet}...{Style.RESET_ALL}"
        #
        #     if print_msg:
        #         print(print_msg)

    def on_agent_action(
        self,
        action: AgentAction,
        *,
        run_id: UUID,
        parent_run_id: UUID | None = None,
        **kwargs: Any,
    ) -> Any:
        """
        Run on agent action.

        Args:
            action (AgentAction): The agent action.
            run_id (UUID): The run ID. This is the ID of the current run.
            parent_run_id (UUID): The parent run ID. This is the ID of the parent run.
            kwargs (Any): Additional keyword arguments.
        """

        # print(f"Agent action: {action}")
        print(f"{REASONING_COLOR}{action.log}...{Style.RESET_ALL}")

        return super().on_agent_action(
            action, run_id=run_id, parent_run_id=parent_run_id, **kwargs
        )

    # def on_llm_end(
    #     self,
    #     response: LLMResult,  # Use the correct type hint
    #     *,
    #     run_id: UUID,
    #     parent_run_id: Optional[UUID] = None,
    #     tags: Optional[List[str]] = None,
    #     **kwargs: Any,
    # ) -> Any:
    #     """
    #     Run when LLM ends running.

    #     Args:
    #         response (LLMResult): The response which was generated.
    #         run_id (UUID): The run ID. This is the ID of the current run.
    #         parent_run_id (UUID): The parent run ID. This is the ID of the parent run.
    #         kwargs (Any): Additional keyword arguments
    #     """

    #     log_message = f"[LLM END] Agent: {self.agent_id}"
    #     logger.debug(log_message)

    #     # Check if reasoning steps should be printed
    #     if self.print_reasoning_steps:
    #         try:
    #             # Extract the generated text from the first generation
    #             if response.generations and response.generations[0]:
    #                 first_generation = response.generations[0][0]
    #                 if isinstance(first_generation, ChatGeneration):
    #                     generated_text = first_generation.text.strip()
    #                     if generated_text:  # Only process if there's text
    #                         # Split into lines and print ONLY thought/action lines
    #                         lines = generated_text.splitlines()
    #                         printed_something = (
    #                             False  # Keep track if we printed any thought/action
    #                         )
    #                         for line in lines:
    #                             if "ðŸ¤”" in line:
    #                                 print(
    #                                     f"{REASONING_COLOR}{line[line.find("ðŸ¤”")+len("ðŸ¤”"):].strip()}...{Style.RESET_ALL}"
    #                                 )
    #                                 printed_something = True
    #                             # Else: ignore other lines (like the final answer block)

    #                         # Add a separator only if thoughts/actions were printed
    #                         if printed_something:
    #                             print(
    #                                 f"{REASONING_COLOR}---"
    #                             )  # Use reasoning color for separator

    #                 else:
    #                     logger.warning(
    #                         f"Unexpected generation type in on_llm_end: {type(first_generation)}"
    #                     )
    #             else:
    #                 logger.warning(
    #                     "LLM response structure unexpected or empty in on_llm_end."
    #                 )
    #         except Exception as e:
    #             logger.error(f"Error processing LLM response in callback: {e}")
    #             # Fallback: print the raw response object for debugging if needed
    #             # print(f"{REASONING_COLOR}Raw LLM Response: {response}{Style.RESET_ALL}")

    def on_chain_end(self, outputs, **kwargs):
        """
        Print the agent's 'thought' steps (reasoning before tool calls) in a clean, sequential manner.
        Handles different AIMessage structures from various models (e.g., Gemini, Anthropic).
        Uses REASONING_COLOR for output and msg.id for deduplication.
        """
        if not self.print_reasoning_steps:
            return

        messages = outputs.get("messages") if isinstance(outputs, dict) else None
        if not messages:
            return

        # Use msg.id for deduplication across potentially multiple handlers/calls
        if not hasattr(self, "_printed_message_ids"):
            self._printed_message_ids = set()

        for msg in messages:
            # Process only AIMessages that haven't been printed yet
            if isinstance(msg, AIMessage) and msg.id not in self._printed_message_ids:
                thought_printed_for_msg = False

                # --- Strategy 1: Thought in content string, tool_calls attribute populated (Common for Gemini) ---
                if msg.tool_calls and isinstance(msg.content, str):
                    thought_text = msg.content.strip()
                    if thought_text:
                        print(f"{REASONING_COLOR}{thought_text}{Style.RESET_ALL}")
                        self._printed_message_ids.add(msg.id)
                        thought_printed_for_msg = True

                # --- Strategy 2: Thought in content list before a tool_use/tool_call dict (Common for Anthropic) ---
                elif isinstance(msg.content, list) and not thought_printed_for_msg:
                    for idx, item in enumerate(msg.content):
                        if (
                            isinstance(item, dict)
                            and item.get("type") == "text"
                            and "text" in item
                        ):
                            # Check if the *next* item signals a tool call/use
                            next_item_is_tool = False
                            if idx + 1 < len(msg.content):
                                next_item = msg.content[idx + 1]
                                if isinstance(next_item, dict) and next_item.get(
                                    "type"
                                ) in ["tool_use", "tool_call"]:
                                    next_item_is_tool = True

                            # If text is followed by tool signal, print it as thought
                            if next_item_is_tool:
                                thought_text = item["text"].strip()
                                if thought_text:
                                    print(
                                        f"{REASONING_COLOR}{thought_text}{Style.RESET_ALL}"
                                    )
                                    self._printed_message_ids.add(msg.id)
                                    thought_printed_for_msg = True

                # --- Optional: Fallback/Final Answer logging (if needed) ---
                # Can add logic here to print final answers if msg.content is string and no tool calls were made
                # elif not msg.tool_calls and isinstance(msg.content, str) and not thought_printed_for_msg:
                #     final_answer = msg.content.strip()
                #     if final_answer:
                #         # Avoid printing if it's just a repeat of the last thought?
                #         # print(f"{Fore.GREEN}Final Answer: {final_answer}{Style.RESET_ALL}")
                #         self._printed_message_ids.add(msg.id) # Mark as printed even if we don't display
